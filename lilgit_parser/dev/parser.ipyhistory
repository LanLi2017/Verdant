{"notebook":{"vers":[{"created":0,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.0","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0"]},{"created":1,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0"]},{"created":8,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0"]},{"created":10,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0"]},{"created":20,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0","c.19.0"]},{"created":22,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0","c.19.0","c.20.0"]},{"created":24,"cells":["c.3.0","c.4.0","c.5.0","c.6.0","c.7.1","c.8.0","c.9.0","c.10.0","c.11.0","c.12.0","c.13.0","c.14.0","c.15.0","c.16.0","c.17.0","c.18.0","c.0.0","c.1.0","c.2.0","c.19.0","c.20.0","c.21.0"]}]},"codeCells":[{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":0,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":1,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":2,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":3,"outputVer":"0","content":[],"literal":"import ast\nfrom ast import AST\nimport sys\nimport json","start":{"line":0,"ch":0},"end":{"line":3,"ch":10}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":4,"outputVer":"0","content":[],"literal":"def getPos(text, textPos):\n        snippet = text[:textPos+1]\n        lines = snippet.split(\"\\n\")\n        ln = len(lines)\n        ch = len(lines[-1])\n        return {'line': ln - 1, 'ch': ch - 1, 'pos': textPos} # codemirror is 0 indexed ln/col\n    \n    ","start":{"line":0,"ch":0},"end":{"line":7,"ch":3}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":5,"outputVer":"0","content":[],"literal":"class Visitor:\n    \n    def __init__(self):\n        self.type = None\n        self.content = []\n        self.literal = None\n        self.start = None\n        self.end = None\n        self.itr = None\n        self.textEnd = None\n        \n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        \n    def startVisit(self, node, text, textStart, textEnd):\n        self.type = type(node).__name__\n        self.itr = textStart\n        self.textEnd = textEnd\n        self.start = getPos(text, self.itr)\n            \n    def endVisit(self, text):\n        self.end = getPos(text, self.itr)\n        if(debug): print(\"MADE:\",self.__dict__,\"\\n\")\n        \n    def visitChild(self, childNode, text, forceKind = None):\n        if(childNode is None): return\n        \n        childKind = \"\"\n        if isinstance(childNode, AST):\n            childKind = type(childNode).__name__\n        else: \n            childKind = 'NotNode'\n        if forceKind:\n            childKind = forceKind\n        child = getattr(sys.modules[__name__], childKind+\"Visitor\")()\n        child.visit(childNode, text, self.itr, self.textEnd)\n        self.content.append(child.toJSON())\n        self.itr = child.itr\n            \n        \n    def readTokens(self, text, symbols, comments = False, limit = sys.maxsize):\n        char = text[min(self.itr, len(text) - 1)]\n        count = 0\n        while self.itr < self.textEnd and char in symbols and count < limit:\n            self.content.append({\"syntok\": str(char)})\n            self.itr += 1\n            count += 1\n            if(self.itr >= self.textEnd): char = None\n            else: char = str(text[self.itr])\n        if(comments and char in commentTokens):\n            wasComment = self.captureComment(text)\n            if(wasComment):\n                self.readTokens(text, symbols, comments)\n        return count\n            \n    def captureComment(self, text):\n        line = text[self.itr:self.textEnd]\n        index = line.find(\"\\n\")\n        if(index > -1):\n            line = line[:index]\n            self.itr += len(line)\n            self.content.append({'syntok': line})\n            return True\n        return False\n        \n    def write(self, text):\n        self.content.append({\"syntok\": text})\n        self.itr += len(text)\n    \n    def toJSON(self):\n        return {'type': self.type, 'content': self.content, 'literal': self.literal, 'start': self.start, 'end': self.end}","start":{"line":0,"ch":0},"end":{"line":70,"ch":121}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":6,"outputVer":"0","content":[],"literal":"class NotNodeVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(str(node))\n        self.endVisit(text)","start":{"line":0,"ch":0},"end":{"line":4,"ch":26}}]},{"vers":[{"created":0,"parent":"n.0.0","type":"Module","outputId":7,"outputVer":"0","content":[],"literal":"class StmtExprVisitor(Visitor):\n    def startVisit(self, node, text, textStart, textEnd):\n        self.type = type(node).__name__\n        self.itr = textStart\n        self.textEnd = textEnd\n        self.start = {'line': node.lineno - 1, 'ch': node.col_offset} # codemirror is 0 indexed ln","start":{"line":0,"ch":0},"end":{"line":5,"ch":97}},{"created":1,"parent":"n.0.6","type":"Module","outputId":7,"outputVer":1,"content":[],"literal":"class StmtExprVisitor(Visitor):\n    def startVisit(self, node, text, textStart, textEnd):\n        self.type = type(node).__name__\n        self.itr = textStart\n        self.textEnd = textEnd\n        self.start = {'pos': textStart, 'line': node.lineno - 1, 'ch': node.col_offset} # codemirror is 0 indexed ln","start":{"line":0,"ch":0},"end":{"line":5,"ch":115}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":8,"outputVer":"0","content":[],"literal":"'''\nmod = Module(stmt* body)\n        | Interactive(stmt* body)\n        | Expression(expr body)\n\n        -- not really an actual node but useful in Jython's typesystem.\n        | Suite(stmt* body)\n'''\nclass ModuleVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.readTokens(text, space|newLine, comments = True)\n        \n        # body\n        if(isinstance(node.body, list)):\n            for stmt in node.body:\n                self.visitChild(stmt, text)\n                self.readTokens(text, space|newLine, comments = True)\n        else:\n            self.visitChild(stmt, text)\n    \n        self.readTokens(text, space|newLine, comments = True)\n        self.endVisit(text)\n\nclass InteractiveVisitor(ModuleVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.endVisit(text)\n\nclass ExpressionVisitor(ModuleVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.endVisit(text)\n\nclass SuiteVisitor(ModuleVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.endVisit(text)","start":{"line":0,"ch":0},"end":{"line":37,"ch":26}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":9,"outputVer":"0","content":[],"literal":"'''\nFunctionDef(identifier name, arguments args,\n                       stmt* body, expr* decorator_list, expr? returns)\n'''\nclass FunctionDefVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        #decorators\n        for dec in node.decorator_list:\n            self.visitChild(dec, text)\n            self.readTokens(text, space|newLine, comments = True)\n        self.visitFunction(node, text)   \n        \n    \n    def visitFunction(self, node, text):\n        #def and name\n        self.write(\"def\")\n        self.readTokens(text, space)\n        name = str(node.name)\n        self.write(name)\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n\n        # arguments\n        self.visitChild(node.args, text)\n        self.readTokens(text, space)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.readTokens(text, space)\n  \n        # end function header\n        self.write(\":\")\n        self.readTokens(text, space)\n        \n        # check for return annotation\n        if(node.returns):\n            self.write(\"->\")\n            self.readTokens(text, space)\n            end, ret = visitChild(node.returns, text, end, textEnd)\n            \n        # finally, body of the function\n        for stmt in node.body:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(stmt, text)\n            self.readTokens(text, space, comments = True)\n        self.endVisit(text)\n\n'''\nAsyncFunctionDef(identifier name, arguments args,\n                       stmt* body, expr* decorator_list, expr? returns)\n'''\nclass AsyncFunctionDefVisitor(FunctionDefVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        #decorators\n        for dec in node.decorator_list:\n            self.visitChild(dec, text)\n            self.readTokens(text, space|newLine, comments = True)\n        # add the async token\n        self.write(\"async\")\n        self.readTokens(text, space)\n        self.visitFunction(node, text)   \n\n'''\nClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)\n'''\nclass ClassDefVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        #decorators\n        for dec in node.decorator_list:\n            self.visitChild(dec, text)\n            self.readTokens(text, space|newLine, comments = True)\n            \n        #class and name\n        self.write(\"class\")\n        self.readTokens(text, space)\n        self.write(str(node.name))\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        \n        # bases\n        for base in node.bases:\n            self.visitChild(base, text)\n            #get spaces and commas only\n            self.readTokens(text, space|commas)\n\n        # keywords\n        for key in node.keywords:\n            self.visitChild(key, text)\n            #get spaces and commas only\n            self.readTokens(text, space|commas)\n\n        # end class header\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.readTokens(text, space)\n        self.write(\":\")\n        \n        # finally, body of the class\n        for stmt in node.body:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(stmt, text)\n            self.readTokens(text, space, comments = True)\n        self.endVisit(text)\n    \n    \n'''\nReturn(expr? value)\n'''\nclass ReturnVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"return\")\n        self.readTokens(text, space)\n        if(node.value):\n            self.visitChild(node.value, text)\n            self.readTokens(text, space, comments = True)\n        self.endVisit(text)\n        \n'''\n| Delete(expr* targets)\n'''\nclass DeleteVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"del\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        for target in node.targets:\n            self.readTokens(text, space|commas)\n            openCount = self.readTokens(text, {\"(\"})\n            self.readTokens(text, space| commas)\n            self.visitChild(target, text)\n            if(openCount > 0):\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)  \n        \n'''\n| Assign(expr* targets, expr value)\n'''\nclass AssignVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        for target in node.targets:\n            self.visitChild(target, text)\n            self.readTokens(text, space|commas)\n        self.write(\"=\")   \n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        self.endVisit(text)  \n\n\n'''\n| AugAssign(expr target, operator op, expr value)\n'''\nclass AugAssignVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.target, text)\n        self.readTokens(text, space|commas)\n        self.visitChild(node.op, text)\n        self.write(\"=\")   \n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        self.endVisit(text) \n\n'''\n-- 'simple' indicates that we annotate simple name without parens\n          | AnnAssign(expr target, expr annotation, expr? value, int simple)\n'''\nclass AnnAssignVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openCount = 0\n        \n        # target\n        targetType = type(node.target).__name__\n        if(node.simple == 0 and targetType == \"Name\"):\n            openCount = self.readTokens(text, {\"(\"})\n            self.readTokens(text, space)\n\n        self.visitChild(node.target, text)\n        self.readTokens(text, space)\n        \n        if(node.simple == 0 and targetType == \"Name\"):\n            self.readTokens(text, {\")\"}, limit = openCount)\n            self.readTokens(text, space)\n            \n        # annotation\n        self.write(\":\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.annotation, text)\n        self.readTokens(text, space)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        \n        # value\n        if(node.value):\n            self.readTokens(text, space)\n            self.write(\"=\")  \n            self.readTokens(text, space)\n            self.visitChild(node.value, text)\n\n        self.endVisit(text) \n\n        \n'''\n| For(expr target, expr iter, stmt* body, stmt* orelse)\n'''\nclass ForVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitFor(node, text, textStart, textEnd)\n    \n    def visitFor(self, node, text, textStart, textEnd):\n        self.write(\"for\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.target, text)\n        self.readTokens(text, space)\n        self.write(\"in\")\n        self.readTokens(text, space)\n        self.visitChild(node.iter, text)\n        # get spaces, : and any new line\n        self.readTokens(text, space|newLine|{':'}, comments = True)\n        for stmt in node.body:\n            self.readTokens(text, space|newLine)\n            self.visitChild(stmt, text)\n        for stmt in node.orelse:\n            self.write(\"else\")\n            # get spaces, : and any new line\n            self.readTokens(text, space|newLine|{':'}, comments = True)\n            self.visitChild(stmt, text)\n        self.endVisit(text) \n'''\n| AsyncFor(expr target, expr iter, stmt* body, stmt* orelse)\n'''\nclass AsyncForVisitor(ForVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"async\")\n        self.readTokens(text, space)\n        self.visitFor(node, text, textStart, textEnd)\n\n\n'''\n| While(expr test, stmt* body, stmt* orelse)\n'''\nclass WhileVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"while\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.test, text)\n        self.readTokens(text, space)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.readTokens(text, space|newLine|{':'})\n        for stmt in node.body:\n            self.readTokens(text, space|newLine)\n            self.visitChild(stmt, text)\n\n        for stmt in node.orelse:\n            self.write(\"else\")\n            self.readTokens(text, space)\n            self.readTokens(text, space|newLine|{':'})\n            self.visitChild(stmt, text)\n        self.endVisit(text) \n\n'''\n| If(expr test, stmt* body, stmt* orelse)\n'''\nclass IfVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"if\")\n        self.visitIf(node, text, textStart, textEnd)\n        \n    def visitIf(self, node, text, textStart, textEnd, nested = False):\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.visitChild(node.test, text)\n        self.readTokens(text, space)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.readTokens(text, space|newLine|{':'}, comments = True)\n        for stmt in node.body:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(stmt, text)\n        for stmt in node.orelse:\n            self.readTokens(text, space|newLine, comments = True)\n            sType = type(stmt).__name__\n            if sType == \"If\":\n                self.visitChild(stmt, text, forceKind = 'NestedIf')\n            else:\n                self.write(\"else\")\n                self.readTokens(text, space|newLine|{':'}, comments = True)\n                self.visitChild(stmt, text)\n        self.endVisit(text) \n\nclass NestedIfVisitor(IfVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"elif\")\n        self.visitIf(node, text, textStart, textEnd)\n        \n'''\n| With(withitem* items, stmt* body)\n'''\nclass WithVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"with\")\n        self.visitWith(node, text, textStart, textEnd)\n\n    def visitWith(self, node, text, textStart, textEnd):\n        self.readTokens(text, space)\n        for withitem in node.items:\n            self.visitChild(withitem, text)\n            self.readTokens(text, space|commas)\n        self.readTokens(text, space|newLine|{':'}, comments = True)\n        for stmt in node.body:\n            self.visitChild(stmt, text)\n            self.readTokens(text, space|newLine, comments = True)\n        self.endVisit(text)\n\n'''\n| AsyncWith(withitem* items, stmt* body)\n'''\nclass AsyncWithVisitor(WithVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"async\")\n        self.readTokens(text, space)\n        self.write(\"with\")\n        self.visitWith(node, text, textStart, textEnd)","start":{"line":0,"ch":0},"end":{"line":338,"ch":53}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":10,"outputVer":"0","content":[],"literal":"'''\n| Raise(expr? exc, expr? cause)\n'''\nclass RaiseVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"raise\")\n        if(node.exc):\n            self.readTokens(text, space)\n            openCount = self.readTokens(text, {\"(\"})\n            self.readTokens(text, space)\n            self.visitChild(node.exc, text)\n            if(openCount):\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount)\n        if(node.cause):\n            self.readTokens(text, space)\n            self.write(\"from\")\n            self.readTokens(text, space)\n            self.visitChild(node.cause, text)\n        self.endVisit(text)\n        \n'''\n| Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)\n'''\nclass TryVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"try\")\n        self.readTokens(text, space|newLine|{':'}, comments = True)\n        for stmt in node.body:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(stmt, text)\n        for excepthandle in node.handlers:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(excepthandle, text)\n        for stmt in node.orelse:\n            self.write(\"else\")\n            self.readTokens(text, space|newLine|{':'}, comments = True)\n            self.visitChild(stmt, text)\n        for stmt in node.finalbody:\n            self.readTokens(text, space|newLine, comments = True)\n            self.write(\"finally\")\n            self.readTokens(text, space|newLine|{':'}, comments = True)\n            self.visitChild(stmt, text)\n        self.endVisit(text)\n\n'''\n| Assert(expr test, expr? msg)\n'''\nclass AssertVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"assert\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.test, text)\n        if(openCount):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        if(node.msg):\n            self.readTokens(text, space)\n            self.write(\",\")\n            self.readTokens(text, space)\n            openCount = self.readTokens(text, {\"(\"})\n            self.readTokens(text, space)\n            self.visitChild(node.msg, text)\n            if(openCount):\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text) \n        \n'''\nImport(alias* names)\n'''\nclass ImportVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.visitImport(node, text, textStart, textEnd)\n    \n    def visitImport(self, node, text, textStart, textEnd):\n        self.write(\"import\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        for alias in node.names:\n            self.readTokens(text, space|commas)\n            self.visitChild(alias, text)\n        if(openCount):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text) \n\n'''\nImportFrom(identifier? module, alias* names, int? level)\n'''\nclass ImportFromVisitor(ImportVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"from\")\n        self.readTokens(text, space)\n        self.write(str(node.module))\n        self.readTokens(text, space)\n        self.visitImport(node, text, textStart, textEnd)\n        \n'''\n| Global(identifier* names)\n'''\nclass GlobalVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"global\")\n        for name in node.names:\n            self.readTokens(text, space|commas)\n            self.write(str(name))\n        self.endVisit(text)  \n\n'''\n| Nonlocal(identifier* names)\n'''\nclass NonlocalVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"nonlocal\")\n        for name in node.names:\n            self.readTokens(text, space|commas)\n            self.write(str(name))\n        self.endVisit(text) \n        \n'''\n| Pass\n'''\nclass PassVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"pass\")\n        self.endVisit(text) \n\n'''\n| Continue\n'''\nclass ContinueVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"continue\")\n        self.endVisit(text) \n\n'''\n| Break\n'''\nclass BreakVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"break\")\n        self.endVisit(text) \n  \n'''\nBoolOp(boolop op, expr* values)\n'''\nclass BoolOpVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        for i, value in enumerate(node.values):\n            self.visitChild(value, text)\n            if(i < len(node.values) - 1):\n                self.readTokens(text, space)\n                self.visitChild(node.op, text)\n                self.readTokens(text, space)\n        self.endVisit(text)\n\n\n'''\n| BinOp(expr left, operator op, expr right)\n'''\nclass BinOpVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.visitChild(node.left, text)\n        self.readTokens(text, space)\n        self.visitChild(node.op, text)\n        self.readTokens(text, space)\n        self.visitChild(node.right, text)\n        self.endVisit(text) \n\n'''\n| UnaryOp(unaryop op, expr operand)\n'''\nclass UnaryOpVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.visitChild(node.op, text)\n        self.readTokens(text, space)\n        self.visitChild(node.operand, text)\n        self.endVisit(text) \n\n'''\n| Lambda(arguments args, expr body)\n'''\nclass LambdaVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"lambda\")\n        self.readTokens(text, space)\n        self.visitChild(node.args, text)\n        self.readTokens(text, space|{\":\"})\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.body, text)\n        if(openCount):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text) \n        \n\n'''\n| IfExp(expr test, expr body, expr orelse)\n'''\nclass IfExpVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.readTokens(text, {\"(\"})\n        self.visitChild(node.body, text)\n        self.readTokens(text, space|{\")\"})\n        self.write(\"if\")\n        self.readTokens(text, space|{\"(\"})\n        self.visitChild(node.test, text)\n        self.readTokens(text, space|{\"(\", \")\"})\n        self.write(\"else\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.orelse, text)\n        if(openCount):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text) \n\n'''\n| Dict(expr* keys, expr* values)\n'''\nclass DictVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"{\")\n        for i, key in enumerate(node.keys):\n            self.readTokens(text, space|{\"(\"}|commas)\n            self.visitChild(key, text)\n            self.readTokens(text, space|{\")\"})\n            self.write(\":\")\n            self.readTokens(text, space|{\"(\"})\n            self.visitChild(node.values[i], text)\n            self.readTokens(text, space|{\")\"})\n        self.write(\"}\")    \n        self.endVisit(text) \n        \n'''\n| Set(expr* elts)\n'''\nclass SetVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"{\")\n        for i, key in enumerate(node.elts):\n            self.readTokens(text, space|{\"(\"}|commas)\n            self.visitChild(key, text)\n            self.readTokens(text, space|{\")\"})\n        self.write(\"}\")    \n        self.endVisit(text) \n        \n'''\n| ListComp(expr elt, comprehension* generators)\n'''\nclass ListCompVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"[\")\n        self.readTokens(text, space)\n        self.visitChild(node.elt, text)\n        self.readTokens(text, space)\n        self.endVisit(text) \n        for gen in node.generators :\n            self.readTokens(text, space)\n            self.visitChild(gen, text)\n        self.write(\"]\")    \n        self.endVisit(text) \n\n\n'''\n| SetComp(expr elt, comprehension* generators)\n'''\nclass SetCompVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"{\")\n        self.readTokens(text, space)\n        self.visitChild(node.elt, text)\n        self.readTokens(text, space)\n        self.endVisit(text) \n        for gen in node.generators :\n            self.readTokens(text, space)\n            self.visitChild(gen, text)\n        self.write(\"}\")    \n        self.endVisit(text) \n\n\n'''\n| DictComp(expr key, expr value, comprehension* generators)\n'''\nclass DictCompVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"{\")\n        self.readTokens(text, space)\n        self.visitChild(node.key, text)\n        self.write(\":\")\n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        self.readTokens(text, space)\n        self.endVisit(text) \n        for gen in node.generators :\n            self.readTokens(text, space)\n            self.visitChild(gen, text)\n        self.write(\"}\")    \n        self.endVisit(text) \n\n'''\n| GeneratorExp(expr elt, comprehension* generators)\n'''\nclass GeneratorExpVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"(\")\n        self.readTokens(text, space)\n        self.visitChild(node.elt, text)\n        self.readTokens(text, space)\n        self.endVisit(text) \n        for gen in node.generators :\n            self.readTokens(text, space)\n            self.visitChild(gen, text)\n        self.write(\")\")    \n        self.endVisit(text) \n        \n\n'''\n| Yield(expr? value)\n'''\nclass YieldVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"yield\")\n        if(node.value):\n            self.readTokens(text, space)\n            self.visitChild(node.value, text)\n        self.endVisit(text) \n\n'''\n| YieldFrom(expr value)\n'''\nclass YieldFromVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"yield\")\n        self.readTokens(text, space)\n        self.write(\"from\")\n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        self.endVisit(text) ","start":{"line":0,"ch":0},"end":{"line":367,"ch":27}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":11,"outputVer":"0","content":[],"literal":"class OpVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(self.getOp())\n        self.endVisit(text)\n        \n    def getOp(self):\n        return None\n    \n'''\nboolop = And | Or\n'''\nclass AndVisitor(OpVisitor):\n    def getOp(self):\n        return \"and\"\n    \nclass OrVisitor(OpVisitor):\n    def getOp(self):\n        return \"or\"\n\n'''\noperator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n             | RShift | BitOr | BitXor | BitAnd | FloorDiv\n'''\nclass AddVisitor(OpVisitor):\n    def getOp(self):\n        return \"+\"\nclass SubVisitor(OpVisitor):\n    def getOp(self):\n        return \"-\"\nclass MultVisitor(OpVisitor):\n    def getOp(self):\n        return \"*\"\nclass MatMultVisitor(OpVisitor):\n    def getOp(self):\n        return \"*\"\nclass DivVisitor(OpVisitor):\n    def getOp(self):\n        return \"/\"\nclass ModVisitor(OpVisitor):\n    def getOp(self):\n        return \"%\"\nclass PowVisitor(OpVisitor):\n    def getOp(self):\n        return \"**\"\nclass LShiftVisitor(OpVisitor):\n    def getOp(self):\n        return \"<<\"\nclass RShiftVisitor(OpVisitor):\n    def getOp(self):\n        return \">>\"\nclass BitOrVisitor(OpVisitor):\n    def getOp(self):\n        return \"|\"\nclass BitXorVisitor(OpVisitor):\n    def getOp(self):\n        return \"^\"\nclass BitAndVisitor(OpVisitor):\n    def getOp(self):\n        return \"&\"\nclass FloorDiv(OpVisitor):\n    def getOp(self):\n        return \"//\"\n    \n'''\nunaryop = Invert | Not | UAdd | USub\n'''\nclass InvertVisitor(OpVisitor):\n    def getOp(self):\n        return \"~\"\nclass NotVisitor(OpVisitor):\n    def getOp(self):\n        return \"not\"\nclass UAddVisitor(OpVisitor):\n    def getOp(self):\n        return \"+\"\nclass USubVisitor(OpVisitor):\n    def getOp(self):\n        return \"-\"\n    \n'''\ncmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n'''\nclass EqVisitor(OpVisitor):\n    def getOp(self):\n        return \"==\"\nclass NotEqVisitor(OpVisitor):\n    def getOp(self):\n        return \"!=\"\nclass LtVisitor(OpVisitor):\n    def getOp(self):\n        return \"<\"\nclass LtEVisitor(OpVisitor):\n    def getOp(self):\n        return \"<=\"\nclass GtVisitor(OpVisitor):\n    def getOp(self):\n        return \">\"\nclass GtEVisitor(OpVisitor):\n    def getOp(self):\n        return \">=\"\nclass IsVisitor(OpVisitor):\n    def getOp(self):\n        return \"is\"\nclass IsNotVisitor(OpVisitor):\n    def getOp(self):\n        return \"is not\"\nclass InVisitor(OpVisitor):\n    def getOp(self):\n        return \"in\"\nclass NotInVisitor(OpVisitor):\n    def getOp(self):\n        return \"not in\"","start":{"line":0,"ch":0},"end":{"line":112,"ch":22}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":12,"outputVer":"0","content":[],"literal":"'''\n comprehension = (expr target, expr iter, expr* ifs, int is_async)\n'''\nclass comprehensionVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        if(node.is_async):\n            self.write(\"async\")\n            self.readTokens(text, space)\n        self.write(\"for\")\n        self.readTokens(text, space)\n        self.visitChild(node.target, text)\n        self.readTokens(text, space)\n        self.write(\"in\")\n        self.visitChild(node.iter, text)\n        # ifs\n        for iff in node.ifs:\n            self.readTokens(text, space)\n            self.write(\"if\")\n            self.readTokens(text, space)\n            self.visitChild(iff, text)\n        self.endVisit(text) \n\n\n'''\nexcepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n                    attributes (int lineno, int col_offset)\n'''\nclass ExceptHandlerVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"except\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        if node.type:\n            self.readTokens(text, space)\n            self.visitChild(node.type, text)\n        if node.name:\n            self.readTokens(text, space)\n            self.write(\"as\")\n            self.readTokens(text, space)\n            self.write(str(node.name))\n        self.readTokens(text, space)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.readTokens(text, space|newLine|{':'}, comments = True)\n        for stmt in node.body:\n            self.readTokens(text, space|newLine, comments = True)\n            self.visitChild(stmt, text)\n        self.endVisit(text)\n\n\n'''\narguments = (arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults,\n                 arg? kwarg, expr* defaults)\n'''\nclass argumentsVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        # args\n        for ind, arg in enumerate(node.args):\n            self.readTokens(text, space|commas)\n            self.visitChild(arg, text)\n            if(node.defaults and (ind - len(node.defaults) + 1 > -1)):\n                dind = ind - len(node.defaults) + 1\n                if(dind < len(node.defaults) - 1 and node.defaults[dind]):\n                    self.readTokens(text, space)\n                    self.write(\"=\")\n                    self.readTokens(text, space)\n                    self.visitChild(node.defaults[dind], text)\n        # vararg   \n        if(node.vararg):\n            self.readTokens(text, space|commas)\n            self.write(\"*\")\n            self.visitChild(node.vararg, text)\n        # kwonlyargs\n        for ind, kwo in enumerate(node.kwonlyargs):\n            self.readTokens(text, space|commas)\n            self.visitChild(kwo, text)\n            if(node.kw_defaults and node.kw_defaults[ind]):\n                self.readTokens(text, space)\n                self.write(\"=\")\n                self.readTokens(text, space)\n                self.visitChild(node.kw_defaults[ind], text)\n        # kwarg\n        if(node.kwarg):\n            self.readTokens(text, space|commas)\n            self.write(\"**\")\n            self.visitChild(node.kwarg, text)\n        self.endVisit(text)\n\n\n'''\narg = (identifier arg, expr? annotation)\n           attributes (int lineno, int col_offset)\n'''\nclass argVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(str(node.arg))\n        if(node.annotation):\n            self.readTokens(text, space)\n            self.write(\":\")\n            self.readTokens(text, space)\n            self.visitChild(node.annotation, text)\n        self.endVisit(text)\n        \n\n'''\n-- import name with optional 'as' alias.\n    alias = (identifier name, identifier? asname)\n'''\nclass aliasVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.readTokens(text, space)\n        self.write(str(node.name))\n        if(node.asname):\n            self.readTokens(text, space)\n            self.write(\"as\")\n            self.readTokens(text, space)\n            self.write(str(node.asname))\n        self.endVisit(text)\n        \n\n'''\nkeyword = (identifier? arg, expr value)\n'''\nclass keywordVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.arg, text)\n        self.readTokens(text, space|{'='})\n        self.visitChild(node.value, text)\n        self.endVisit(text)\n        \n'''\nwithitem = (expr context_expr, expr? optional_vars)\n'''\nclass withitemVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openCount = self.readTokens(text, {\"(\"})\n        self.visitChild(node.context_expr, text)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        if(node.optional_vars):\n            self.readTokens(text, space)\n            self.write(\"as\")\n            self.readTokens(text, space)\n            openCount = self.readTokens(text, {\"(\"})\n            self.readTokens(text, space)\n            self.visitChild(node.optional_vars, text)\n            if openCount > 0:\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)\n        ","start":{"line":0,"ch":0},"end":{"line":155,"ch":7}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":13,"outputVer":"0","content":[],"literal":"'''\nExpr(expr value)\n'''\nclass ExprVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.value, text)\n        self.endVisit(text)","start":{"line":0,"ch":0},"end":{"line":7,"ch":26}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":14,"outputVer":"0","content":[],"literal":"'''\n| Await(expr value)\n'''\nclass AwaitVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"await\")\n        self.readTokens(text, space)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        if(openCount > 0):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)\n        \n\n\n'''\n-- need sequences for compare to distinguish between\n-- x < 4 < 3 and (x < 4) < 3\n| Compare(expr left, cmpop* ops, expr* comparators)\n'''\nclass CompareVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n\n        # get left expr\n        self.visitChild(node.left, text)\n\n        if(node.ops):\n            self.readTokens(text, space)\n            for cmpop in node.ops:\n                openCount2 = self.readTokens(text, {\"(\"})\n                self.readTokens(text, space)\n                self.visitChild(cmpop, text)\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount2)\n\n        if(node.comparators):\n            self.readTokens(text, space)\n            for expr in node.comparators:\n                openCount3 = self.readTokens(text, {\"(\"})\n                self.readTokens(text, space)\n                self.visitChild(expr, text)\n                self.readTokens(text, space)\n                self.readTokens(text, {\")\"}, limit = openCount3)\n                \n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)\n    \n        \n'''\nCall(expr func, expr* args, keyword* keywords)\n'''\nclass CallVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.func, text)\n        openCount = self.readTokens(text, {\"(\"})\n        \n        self.readTokens(text, space)\n        for argument in node.args:\n            self.readTokens(text, space|commas)\n            self.visitChild(argument, text)\n        for keyword in node.keywords:\n            self.readTokens(text, space|commas)\n            self.visitChild(keyword, text)\n            \n        self.readTokens(text, space|commas)\n        self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)\n\n\n\n'''\n| Num(object n) -- a number as a PyObject.\nwe need this one while we don't need one for Str because we need special regex for decimals\n'''\nclass NumVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        value = str(node.n)\n        self.literal = value\n        self.itr += len(value)\n        self.endVisit(text)\n\n'''\n| Str(string s) -- need to specify raw, unicode, etc?\n'''\nclass StrVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openQuotes = self.readTokens(text, quotes)\n        self.write(str(node.s))\n        self.readTokens(text, quotes, limit = openQuotes)\n        self.endVisit(text)\n        \n\n'''\n | Name(identifier id, expr_context ctx)\n'''\nclass NameVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openCount = self.readTokens(text, {\"(\"})\n        self.readTokens(text, space)\n        self.write(str(node.id))\n        if(openCount):\n            self.readTokens(text, space)\n            self.readTokens(text, {\")\"}, limit = openCount)\n        self.endVisit(text)\n    \n\n'''\n| FormattedValue(expr value, int? conversion, expr? format_spec)\n'''\nclass FormattedValueVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        openCount = self.readTokens(text, {\"{\"})\n        self.readTokens(text, space)\n        self.visitChild(node.value, text)\n        if(node.format_spec):\n            self.readTokens(text, space)\n            self.write(\":\")\n            self.visitChild(node.format_spec, text, forceKind = 'NestedJoinedStr')\n            self.readTokens(text, space)\n        self.readTokens(text, {\"}\"}, limit = openCount)\n        self.endVisit(text)\n    \n'''\n| JoinedStr(expr* values)\n'''\nclass JoinedStrVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"f\\\"\")\n        for val in node.values:\n            self.visitChild(val, text)\n        self.write(\"\\\"\")\n        self.endVisit(text)\nclass NestedJoinedStrVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        for val in node.values:\n            self.visitChild(val, text)\n        self.endVisit(text)\n\n'''\n| Bytes(bytes s)\n'''\nclass BytesVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(str(node.s))\n        self.endVisit(text)\n\n'''\n| NameConstant(singleton value)\n'''\nclass NameConstantVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(str(node.value))\n        self.endVisit(text)\n\n'''\n| Ellipsis\n'''\nclass EllipsisVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"...\")\n        self.endVisit(text)\n\n'''\n| Constant(constant value)\n'''\nclass ConstantVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(str(node.value))\n        self.endVisit(text)\n\n\n'''\n| Attribute(expr value, identifier attr, expr_context ctx)\n'''\nclass AttributeVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.value, text)\n        self.write(\".\")\n        self.visitChild(node.attr, text)\n        self.endVisit(text)\n\n'''\n| Subscript(expr value, slice slice, expr_context ctx)\n'''\nclass SubscriptVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.value, text)\n        openCount = self.readTokens(text, {\"[\"})\n        self.readTokens(text, space)\n        self.visitChild(node.slice, text)\n        self.readTokens(text, space)\n        self.readTokens(text, {\"]\"}, limit = openCount)\n        self.endVisit(text)\n\n\n'''\n| Starred(expr value, expr_context ctx)\n'''\nclass StarredVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.write(\"*\")\n        self.visitChild(node.value, text)\n        self.endVisit(text)\n    \n    \n'''\n| List(expr* elts, expr_context ctx)\n'''\nclass ListVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"[\")\n        for i, key in enumerate(node.elts):\n            self.readTokens(text, space|{\"(\"}|commas)\n            self.visitChild(key, text)\n            self.readTokens(text, space|{\")\"})\n        self.write(\"]\")    \n        self.endVisit(text) \n\n'''\n| List(expr* elts, expr_context ctx)\n'''\nclass TupleVisitor(StmtExprVisitor):\n    def visit(self, node, text, textStart, textEnd):\n        self.startVisit(node, text, textStart, textEnd)\n        self.write(\"(\")\n        for i, key in enumerate(node.elts):\n            self.readTokens(text, space|commas)\n            self.visitChild(key, text)\n            self.readTokens(text, space)\n        self.write(\")\")    \n        self.endVisit(text) \n        \n'''\nSlice(expr? lower, expr? upper, expr? step)\n'''\nclass SliceVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.lower, text)\n        self.readTokens(text, space|{\":\"})\n        self.visitChild(node.upper, text)\n        if(node.step):\n            self.readTokens(text, space|{\":\"})\n            self.visitChild(node.step, text)\n        self.endVisit(text)  \n\n'''\n| ExtSlice(slice* dims)\n'''\nclass ExtSliceVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        for dim in node.dims:\n            self.readTokens(text, space|{\",\"})\n            self.visitChild(dim, text)\n        self.endVisit(text)  \n        \n\n'''\n| Index(expr value)\n'''\nclass IndexVisitor(Visitor):\n    def visit(self, node, text, textStart, textEnd):\n        super().visit(node, text, textStart, textEnd)\n        self.visitChild(node.value, text)\n        self.endVisit(text)  ","start":{"line":0,"ch":0},"end":{"line":286,"ch":28}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":15,"outputVer":"0","content":[],"literal":"space = {\"\\t\", \" \"}\nnewLine = {\"\\n\", \"\\r\"} #todo may vary across platforms\ncommentTokens = {\"#\",\"'''\"}\ncommas = {\",\"}\nquotes = {\"'\", '\"'}","start":{"line":0,"ch":0},"end":{"line":4,"ch":18}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":16,"outputVer":"0","content":[],"literal":"debug = False\ntest = \"\"\"ollie = 'OK!'\"\"\"\nif(debug):\n    visitor = parse(test)\n    print(visitor)","start":{"line":0,"ch":0},"end":{"line":4,"ch":17}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":17,"outputVer":"0","content":[],"literal":"def parse(code):\n    if(code == \"\"):\n        return {'type': 'Module', 'content': [], 'literal': None, 'start': {'line': 0, 'ch': 0}, 'end': {'line': 0, 'ch': 0}}\n    node = ast.parse(code)\n    visitor = ModuleVisitor()\n    visitor.visit(node, code, 0, len(code))\n    return visitor.toJSON()","start":{"line":0,"ch":0},"end":{"line":6,"ch":26}}]},{"vers":[{"created":0,"parent":"n.0.6","type":"Module","outputId":18,"outputVer":"0","content":[],"literal":"# TESTS\n\n'''\nA function that takes a formatted nodey and translates it to sourcode.\nIf our parser is correct, we should expect the translated sourcecode and the input text to be the same.\n'''\ndef translateBack(nodey):\n    code = []\n    if nodey['literal']:\n        code = nodey['literal']\n    else:\n        for item in nodey['content']:\n            if 'syntok' in item:\n                code.append(item['syntok'])\n            else:\n                code.append(translateBack(item))\n    return \"\".join(code)\n\nif(debug): print(translateBack(visitor))\n","start":{"line":0,"ch":0},"end":{"line":19,"ch":-1}}]},{"vers":[{"created":20,"parent":"n.0.6","type":"Module","outputId":19,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]},{"vers":[{"created":22,"parent":"n.0.6","type":"Module","outputId":20,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]},{"vers":[{"created":24,"parent":"n.0.6","type":"Module","outputId":21,"outputVer":"0","content":[],"start":{"line":1,"ch":0},"end":{"line":1,"ch":0}}]}],"markdownCells":[],"snippets":[],"output":[{"vers":[{"created":0,"parent":"c.0.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.1.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.2.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.3.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.4.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.5.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.6.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.7.0","raw":[]},{"created":1,"parent":"c.7.1","raw":[{"traceback":["\u001b[0;31m--------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m        Traceback (most recent call last)","\u001b[0;32m<ipython-input-1-747bbab5d62f>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0;32mclass\u001b[0m \u001b[0mStmtExprVisitor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mVisitor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mstartVisit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtext\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtextStart\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtextEnd\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtype\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name__\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mitr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtextStart\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtextEnd\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtextEnd\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mNameError\u001b[0m: name 'Visitor' is not defined"],"ename":"NameError","evalue":"name 'Visitor' is not defined","output_type":"error"}]},{"created":6,"parent":"c.7.1","raw":[]}]},{"vers":[{"created":0,"parent":"c.8.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.9.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.10.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.11.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.12.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.13.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.14.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.15.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.16.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.17.0","raw":[]}]},{"vers":[{"created":0,"parent":"c.18.0","raw":[]}]},{"vers":[{"created":20,"parent":"c.19.0","raw":[]}]},{"vers":[{"created":22,"parent":"c.20.0","raw":[]}]},{"vers":[{"created":24,"parent":"c.21.0","raw":[]}]}],"runs":[{"checkpointType":"l","timestamp":1556132610201,"notebook":0,"targetCells":[{"node":"c.0.0","changeType":1},{"node":"c.1.0","changeType":1},{"node":"c.2.0","changeType":1},{"node":"c.3.0","changeType":1},{"node":"c.4.0","changeType":1},{"node":"c.5.0","changeType":1},{"node":"c.6.0","changeType":1},{"node":"c.7.0","changeType":1},{"node":"c.8.0","changeType":1},{"node":"c.9.0","changeType":1},{"node":"c.10.0","changeType":1},{"node":"c.11.0","changeType":1},{"node":"c.12.0","changeType":1},{"node":"c.13.0","changeType":1},{"node":"c.14.0","changeType":1},{"node":"c.15.0","changeType":1},{"node":"c.16.0","changeType":1},{"node":"c.17.0","changeType":1},{"node":"c.18.0","changeType":1}]},{"checkpointType":"s","timestamp":1556133151466,"notebook":1,"targetCells":[{"node":"c.7.1","changeType":2,"run":true,"newOutput":["o.7.1"]}]},{"checkpointType":"r","timestamp":1556133153579,"notebook":1,"targetCells":[{"node":"c.3.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133153787,"notebook":1,"targetCells":[{"node":"c.4.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133153998,"notebook":1,"targetCells":[{"node":"c.5.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133154170,"notebook":1,"targetCells":[{"node":"c.6.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133154320,"notebook":1,"targetCells":[{"node":"c.7.1","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133154458,"notebook":1,"targetCells":[{"node":"c.8.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133154669,"notebook":2,"targetCells":[{"node":"c.9.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133155399,"notebook":2,"targetCells":[{"node":"c.10.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156421,"notebook":3,"targetCells":[{"node":"c.0.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156495,"notebook":3,"targetCells":[{"node":"c.1.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156625,"notebook":3,"targetCells":[{"node":"c.11.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156702,"notebook":3,"targetCells":[{"node":"c.12.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156900,"notebook":3,"targetCells":[{"node":"c.13.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133156953,"notebook":3,"targetCells":[{"node":"c.14.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133157449,"notebook":3,"targetCells":[{"node":"c.15.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133157500,"notebook":3,"targetCells":[{"node":"c.16.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133157531,"notebook":3,"targetCells":[{"node":"c.17.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"r","timestamp":1556133157565,"notebook":3,"targetCells":[{"node":"c.18.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"a","timestamp":1556133157668,"notebook":4,"targetCells":[{"node":"c.19.0","changeType":1}]},{"checkpointType":"r","timestamp":1556133157669,"notebook":4,"targetCells":[{"node":"c.2.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"a","timestamp":1556133157783,"notebook":5,"targetCells":[{"node":"c.20.0","changeType":1}]},{"checkpointType":"r","timestamp":1556133157783,"notebook":5,"targetCells":[{"node":"c.19.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"a","timestamp":1556133157884,"notebook":6,"targetCells":[{"node":"c.21.0","changeType":1}]},{"checkpointType":"r","timestamp":1556133157885,"notebook":6,"targetCells":[{"node":"c.20.0","changeType":2,"run":true,"newOutput":[]}]},{"checkpointType":"s","timestamp":1556133167570,"notebook":6,"targetCells":[]}]}